/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => PARAArchivePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// settings.ts
var DEFAULT_SETTINGS = {
  archiveConfigs: [
    {
      id: "default",
      name: "Default",
      rootPath: "",
      archivePath: "Archive",
      archiveMode: "path-mirror"
    }
  ],
  showConfirmation: true,
  linkUpdateMode: "always"
};

// settings-tab.ts
var import_obsidian2 = require("obsidian");

// folder-suggest.ts
var import_obsidian = require("obsidian");
var FolderSuggest = class extends import_obsidian.AbstractInputSuggest {
  constructor(app, inputEl, onSelectCallback) {
    super(app, inputEl);
    this.onSelectCallback = onSelectCallback;
  }
  getSuggestions(query) {
    const allFolders = this.app.vault.getAllFolders();
    const lowerCaseInputStr = query.toLowerCase();
    return allFolders.filter((folder) => {
      return folder.path.toLowerCase().contains(lowerCaseInputStr);
    });
  }
  renderSuggestion(folder, el) {
    el.createEl("div", { text: folder.path });
  }
  selectSuggestion(folder) {
    this.setValue(folder.path);
    if (this.onSelectCallback) {
      this.onSelectCallback(folder.path);
    }
    this.close();
  }
};

// settings-tab.ts
var PARAArchiveSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "PARA Archive Settings" });
    new import_obsidian2.Setting(containerEl).setName("Show confirmation dialog").setDesc("Show a confirmation dialog before archiving files").addToggle((toggle) => toggle.setValue(this.plugin.settings.showConfirmation).onChange(async (value) => {
      this.plugin.settings.showConfirmation = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Link update mode").setDesc("How to handle internal links when archiving files").addDropdown((dropdown) => dropdown.addOption("always", "Always update links").addOption("ask", "Ask before updating").addOption("never", "Never update links").setValue(this.plugin.settings.linkUpdateMode).onChange(async (value) => {
      this.plugin.settings.linkUpdateMode = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Archive Configurations" });
    containerEl.createEl("p", { text: "Configure different archive setups for different parts of your vault (e.g., Personal, Work)" });
    new import_obsidian2.Setting(containerEl).setName("Add new archive configuration").addButton((button) => button.setButtonText("Add").setCta().onClick(() => {
      this.addNewArchiveConfig();
    }));
    this.plugin.settings.archiveConfigs.forEach((config, index) => {
      this.displayArchiveConfig(containerEl, config, index);
    });
  }
  addNewArchiveConfig() {
    const newConfig = {
      id: Date.now().toString(),
      name: "New Configuration",
      rootPath: "",
      archivePath: "Archive",
      archiveMode: "date-based"
    };
    this.plugin.settings.archiveConfigs.push(newConfig);
    this.plugin.saveSettings();
    this.display();
  }
  displayArchiveConfig(containerEl, config, index) {
    const configDiv = containerEl.createDiv("archive-config");
    configDiv.createEl("h4", { text: `Configuration: ${config.name}` });
    new import_obsidian2.Setting(configDiv).setName("Configuration name").setDesc("A friendly name for this archive configuration").addText((text) => text.setValue(config.name).onChange(async (value) => {
      config.name = value;
      await this.plugin.saveSettings();
      configDiv.querySelector("h4").textContent = `Configuration: ${config.name}`;
    }));
    new import_obsidian2.Setting(configDiv).setName("Root path").setDesc('The root folder path this configuration applies to (e.g., "Personal", "Work"). Leave empty for vault root.').addSearch((search) => {
      search.setPlaceholder("Select or type folder path...").setValue(config.rootPath).onChange(async (value) => {
        config.rootPath = value;
        await this.plugin.saveSettings();
      });
      new FolderSuggest(this.app, search.inputEl, async (value) => {
        config.rootPath = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(configDiv).setName("Archive path").setDesc("The folder where archived files will be moved (relative to root path)").addSearch((search) => {
      search.setPlaceholder("Select or type archive folder path...").setValue(config.archivePath).onChange(async (value) => {
        config.archivePath = value;
        await this.plugin.saveSettings();
      });
      new FolderSuggest(this.app, search.inputEl, async (value) => {
        config.archivePath = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(configDiv).setName("Archive mode").setDesc("How files should be organized in the archive folder").addDropdown((dropdown) => dropdown.addOption("date-based", "Date-based (YYYY-MM folders)").addOption("path-mirror", "Mirror original path structure").setValue(config.archiveMode).onChange(async (value) => {
      config.archiveMode = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(configDiv).setName("Remove configuration").addButton((button) => button.setButtonText("Remove").setWarning().onClick(async () => {
      this.plugin.settings.archiveConfigs.splice(index, 1);
      await this.plugin.saveSettings();
      this.display();
    }));
    configDiv.createEl("hr");
  }
};

// archiver.ts
var import_obsidian3 = require("obsidian");
var Archiver = class {
  constructor(vault) {
    this.vault = vault;
  }
  /**
   * Determines which archive configuration applies to a given file path
   */
  findArchiveConfig(filePath, configs) {
    const sortedConfigs = configs.sort((a, b) => b.rootPath.length - a.rootPath.length);
    for (const config of sortedConfigs) {
      if (this.isFileInRoot(filePath, config.rootPath)) {
        return config;
      }
    }
    return null;
  }
  /**
   * Checks if a file is already in an archive folder
   */
  isFileInArchive(filePath, configs) {
    for (const config of configs) {
      const archiveFullPath = this.getArchiveFullPath(config);
      if (filePath.startsWith(archiveFullPath + "/") || filePath === archiveFullPath) {
        return true;
      }
    }
    return false;
  }
  /**
   * Generates the destination path for archiving a file
   */
  generateArchivePath(filePath, config) {
    const archiveBasePath = this.getArchiveFullPath(config);
    if (config.archiveMode === "date-based") {
      return this.generateDateBasedPath(filePath, archiveBasePath);
    } else {
      return this.generatePathMirrorPath(filePath, config, archiveBasePath);
    }
  }
  /**
   * Archives a file or folder to the appropriate location
   */
  async archiveFile(file, config) {
    const destinationPath = this.generateArchivePath(file.path, config);
    await this.ensureDirectoryExists(destinationPath);
    await this.vault.rename(file, destinationPath);
    return destinationPath;
  }
  isFileInRoot(filePath, rootPath) {
    if (!rootPath) {
      return true;
    }
    const normalizedRoot = (0, import_obsidian3.normalizePath)(rootPath);
    const normalizedFile = (0, import_obsidian3.normalizePath)(filePath);
    return normalizedFile.startsWith(normalizedRoot + "/") || normalizedFile === normalizedRoot;
  }
  getArchiveFullPath(config) {
    if (!config.rootPath || config.archivePath.startsWith(config.rootPath)) {
      return (0, import_obsidian3.normalizePath)(config.archivePath);
    }
    return (0, import_obsidian3.normalizePath)(`${config.rootPath}/${config.archivePath}`);
  }
  generateDateBasedPath(filePath, archiveBasePath) {
    const now = new Date();
    const yearMonth = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, "0")}`;
    const fileName = filePath.split("/").pop() || "";
    return (0, import_obsidian3.normalizePath)(`${archiveBasePath}/${yearMonth}/${fileName}`);
  }
  generatePathMirrorPath(filePath, config, archiveBasePath) {
    let relativePath = filePath;
    if (config.rootPath) {
      const normalizedRoot = (0, import_obsidian3.normalizePath)(config.rootPath);
      if (filePath.startsWith(normalizedRoot + "/")) {
        relativePath = filePath.substring(normalizedRoot.length + 1);
      } else if (filePath === normalizedRoot) {
        relativePath = normalizedRoot.split("/").pop() || "";
      }
    }
    return (0, import_obsidian3.normalizePath)(`${archiveBasePath}/${relativePath}`);
  }
  async ensureDirectoryExists(filePath) {
    const directory = filePath.substring(0, filePath.lastIndexOf("/"));
    if (directory && !this.vault.getAbstractFileByPath(directory)) {
      const pathParts = directory.split("/");
      let currentPath = "";
      for (const part of pathParts) {
        currentPath = currentPath ? `${currentPath}/${part}` : part;
        const normalizedPath = (0, import_obsidian3.normalizePath)(currentPath);
        if (!this.vault.getAbstractFileByPath(normalizedPath)) {
          await this.vault.createFolder(normalizedPath);
        }
      }
    }
  }
};

// link-updater.ts
var LinkUpdater = class {
  constructor(app) {
    this.app = app;
    this.vault = app.vault;
    this.metadataCache = app.metadataCache;
  }
  /**
   * Finds all files that link to the given file
   */
  async findLinksToFile(targetFile) {
    const linkedFiles = [];
    const allFiles = this.vault.getMarkdownFiles();
    for (const file of allFiles) {
      const cache = this.metadataCache.getFileCache(file);
      if (!cache)
        continue;
      if (cache.links) {
        for (const link of cache.links) {
          const linkedFile = this.metadataCache.getFirstLinkpathDest(link.link, file.path);
          if (linkedFile && linkedFile.path === targetFile.path) {
            linkedFiles.push(file);
            break;
          }
        }
      }
      if (cache.embeds) {
        for (const embed of cache.embeds) {
          const linkedFile = this.metadataCache.getFirstLinkpathDest(embed.link, file.path);
          if (linkedFile && linkedFile.path === targetFile.path) {
            if (linkedFiles.indexOf(file) === -1) {
              linkedFiles.push(file);
            }
            break;
          }
        }
      }
    }
    return linkedFiles;
  }
  /**
   * Prepares link updates for all files that reference the moved file
   */
  async prepareLinkUpdates(oldPath, newPath) {
    const updates = [];
    const allFiles = this.vault.getMarkdownFiles();
    for (const file of allFiles) {
      const content = await this.vault.read(file);
      const newContent = this.updateLinksInContent(content, oldPath, newPath, file.path);
      if (content !== newContent) {
        const linkCount = this.countUpdatedLinks(content, newContent);
        updates.push({
          file,
          oldContent: content,
          newContent,
          linkCount
        });
      }
    }
    return updates;
  }
  /**
   * Applies all prepared link updates
   */
  async applyLinkUpdates(updates) {
    let success = 0;
    const failed = [];
    for (const update of updates) {
      try {
        await this.vault.modify(update.file, update.newContent);
        success++;
      } catch (error) {
        failed.push(update.file.path);
        console.error(`Failed to update links in ${update.file.path}:`, error);
      }
    }
    return { success, failed };
  }
  /**
   * Updates all links in content that point to the old path
   */
  updateLinksInContent(content, oldPath, newPath, currentFilePath) {
    var _a;
    let updatedContent = content;
    const oldFileName = ((_a = oldPath.split("/").pop()) == null ? void 0 : _a.replace(/\.[^/.]+$/, "")) || "";
    const newRelativePath = this.getRelativePath(currentFilePath, newPath);
    updatedContent = this.updateWikilinks(updatedContent, oldPath, newPath, oldFileName, newRelativePath, currentFilePath);
    updatedContent = this.updateMarkdownLinks(updatedContent, oldPath, newPath, currentFilePath);
    return updatedContent;
  }
  updateWikilinks(content, oldPath, newPath, oldFileName, newRelativePath, currentFilePath) {
    const wikilinkRegex = /\[\[([^\]|#^]+)([#^][^\]|]*)?\|?([^\]]*)?\]\]/g;
    return content.replace(wikilinkRegex, (match, linkPath, anchor, alias) => {
      const resolvedFile = this.metadataCache.getFirstLinkpathDest(linkPath.trim(), currentFilePath);
      if (resolvedFile && resolvedFile.path === oldPath) {
        const newLinkPath = newRelativePath.replace(/\.[^/.]+$/, "");
        const anchorPart = anchor || "";
        const aliasPart = alias ? `|${alias}` : "";
        return `[[${newLinkPath}${anchorPart}${aliasPart}]]`;
      }
      return match;
    });
  }
  updateMarkdownLinks(content, oldPath, newPath, currentFilePath) {
    const markdownLinkRegex = /(!?)\[([^\]]*)\]\(([^)]+)\)/g;
    return content.replace(markdownLinkRegex, (match, isEmbed, text, linkPath) => {
      const resolvedFile = this.metadataCache.getFirstLinkpathDest(linkPath.trim(), currentFilePath);
      if (resolvedFile && resolvedFile.path === oldPath) {
        const newRelativePath = this.getRelativePath(currentFilePath, newPath);
        return `${isEmbed}[${text}](${newRelativePath})`;
      }
      return match;
    });
  }
  getRelativePath(fromPath, toPath) {
    const fromParts = fromPath.split("/");
    const toParts = toPath.split("/");
    fromParts.pop();
    let commonLength = 0;
    for (let i = 0; i < Math.min(fromParts.length, toParts.length); i++) {
      if (fromParts[i] === toParts[i]) {
        commonLength++;
      } else {
        break;
      }
    }
    const upDirs = fromParts.length - commonLength;
    const relativeParts = [];
    for (let i = 0; i < upDirs; i++) {
      relativeParts.push("..");
    }
    relativeParts.push(...toParts.slice(commonLength));
    return relativeParts.join("/");
  }
  countUpdatedLinks(oldContent, newContent) {
    const oldLinks = (oldContent.match(/\[\[|\]\(/g) || []).length;
    const newLinks = (newContent.match(/\[\[|\]\(/g) || []).length;
    return Math.abs(newLinks - oldLinks);
  }
};

// confirmation-modal.ts
var import_obsidian4 = require("obsidian");
var ArchiveConfirmationModal = class extends import_obsidian4.Modal {
  constructor(app, file, config, destinationPath, linkUpdates, onConfirm, onCancel) {
    super(app);
    this.file = file;
    this.config = config;
    this.destinationPath = destinationPath;
    this.linkUpdates = linkUpdates;
    this.onConfirm = onConfirm;
    this.onCancel = onCancel;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Confirm Archive Operation" });
    const fileInfoDiv = contentEl.createDiv("archive-file-info");
    fileInfoDiv.createEl("h3", { text: "File to Archive" });
    const fileTypeIcon = this.file instanceof import_obsidian4.TFile ? "\u{1F4C4}" : "\u{1F4C1}";
    fileInfoDiv.createEl("p", {
      text: `${fileTypeIcon} ${this.file.name}`,
      cls: "archive-file-name"
    });
    fileInfoDiv.createEl("p", {
      text: `Current path: ${this.file.path}`,
      cls: "archive-current-path"
    });
    const archiveInfoDiv = contentEl.createDiv("archive-destination-info");
    archiveInfoDiv.createEl("h3", { text: "Archive Details" });
    archiveInfoDiv.createEl("p", { text: `Configuration: ${this.config.name}` });
    archiveInfoDiv.createEl("p", { text: `Archive mode: ${this.config.archiveMode}` });
    archiveInfoDiv.createEl("p", {
      text: `Destination: ${this.destinationPath}`,
      cls: "archive-destination-path"
    });
    if (this.linkUpdates.length > 0) {
      const linkInfoDiv = contentEl.createDiv("archive-link-info");
      linkInfoDiv.createEl("h3", { text: "Link Updates" });
      const totalLinks = this.linkUpdates.reduce((sum, update) => sum + update.linkCount, 0);
      linkInfoDiv.createEl("p", {
        text: `${this.linkUpdates.length} files with ${totalLinks} links will be updated`
      });
      const fileList = linkInfoDiv.createEl("ul", { cls: "archive-link-files" });
      const filesToShow = this.linkUpdates.slice(0, 5);
      filesToShow.forEach((update) => {
        const listItem = fileList.createEl("li");
        listItem.createEl("span", { text: update.file.name, cls: "file-name" });
        listItem.createEl("span", {
          text: ` (${update.linkCount} links)`,
          cls: "link-count"
        });
      });
      if (this.linkUpdates.length > 5) {
        fileList.createEl("li", {
          text: `... and ${this.linkUpdates.length - 5} more files`,
          cls: "more-files"
        });
      }
    } else {
      const noLinksDiv = contentEl.createDiv("archive-no-links");
      noLinksDiv.createEl("p", {
        text: "No links to this file were found.",
        cls: "no-links-message"
      });
    }
    const existingFile = this.app.vault.getAbstractFileByPath(this.destinationPath);
    if (existingFile) {
      const warningDiv = contentEl.createDiv("archive-warning");
      warningDiv.createEl("p", {
        text: "\u26A0\uFE0F A file or folder already exists at the destination path. It will be overwritten.",
        cls: "warning-message"
      });
    }
    const buttonDiv = contentEl.createDiv("archive-buttons");
    buttonDiv.createEl("button", { text: "Cancel" }).addEventListener("click", () => {
      this.onCancel();
      this.close();
    });
    const confirmButton = buttonDiv.createEl("button", {
      text: "Archive",
      cls: "mod-cta"
    });
    confirmButton.addEventListener("click", async () => {
      confirmButton.disabled = true;
      confirmButton.textContent = "Archiving...";
      try {
        await this.onConfirm();
        this.close();
      } catch (error) {
        confirmButton.disabled = false;
        confirmButton.textContent = "Archive";
        console.error("Archive operation failed:", error);
      }
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// main.ts
var PARAArchivePlugin = class extends import_obsidian5.Plugin {
  async onload() {
    await this.loadSettings();
    this.archiver = new Archiver(this.app.vault);
    this.linkUpdater = new LinkUpdater(this.app);
    this.addSettingTab(new PARAArchiveSettingTab(this.app, this));
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        this.addArchiveMenuItem(menu, file);
      })
    );
    this.addCommand({
      id: "archive-current-file",
      name: "Archive current file",
      checkCallback: (checking) => {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile) {
          if (!checking) {
            this.archiveFile(activeFile);
          }
          return true;
        }
        return false;
      }
    });
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  addArchiveMenuItem(menu, file) {
    if (this.archiver.isFileInArchive(file.path, this.settings.archiveConfigs)) {
      return;
    }
    const config = this.archiver.findArchiveConfig(file.path, this.settings.archiveConfigs);
    if (!config) {
      return;
    }
    menu.addItem((item) => {
      item.setTitle("PARA Archive").setIcon("archive").onClick(() => {
        this.archiveFile(file);
      });
    });
  }
  async archiveFile(file) {
    try {
      const config = this.archiver.findArchiveConfig(file.path, this.settings.archiveConfigs);
      if (!config) {
        new import_obsidian5.Notice("No archive configuration found for this file location");
        return;
      }
      if (this.archiver.isFileInArchive(file.path, this.settings.archiveConfigs)) {
        new import_obsidian5.Notice("File is already in an archive folder");
        return;
      }
      const destinationPath = this.archiver.generateArchivePath(file.path, config);
      let linkUpdates = [];
      if (this.settings.linkUpdateMode !== "never" && file instanceof import_obsidian5.TFile) {
        linkUpdates = await this.linkUpdater.prepareLinkUpdates(file.path, destinationPath);
      }
      if (this.settings.showConfirmation) {
        new ArchiveConfirmationModal(
          this.app,
          file,
          config,
          destinationPath,
          linkUpdates,
          async () => {
            await this.performArchive(file, config, destinationPath, linkUpdates);
          },
          () => {
          }
        ).open();
      } else {
        await this.performArchive(file, config, destinationPath, linkUpdates);
      }
    } catch (error) {
      console.error("Archive operation failed:", error);
      new import_obsidian5.Notice(`Archive failed: ${error.message}`);
    }
  }
  async performArchive(file, config, destinationPath, linkUpdates) {
    try {
      await this.archiver.archiveFile(file, config);
      if (this.settings.linkUpdateMode === "always" && linkUpdates.length > 0) {
        const result = await this.linkUpdater.applyLinkUpdates(linkUpdates);
        if (result.failed.length > 0) {
          new import_obsidian5.Notice(`File archived. Updated ${result.success} files, failed to update ${result.failed.length} files.`);
        } else {
          new import_obsidian5.Notice(`File archived successfully. Updated ${result.success} files with links.`);
        }
      } else if (this.settings.linkUpdateMode === "ask" && linkUpdates.length > 0) {
        new import_obsidian5.Notice(`File archived. ${linkUpdates.length} files contain links to this file. Use the command palette to update links if needed.`);
      } else {
        new import_obsidian5.Notice("File archived successfully");
      }
    } catch (error) {
      console.error("Archive operation failed:", error);
      new import_obsidian5.Notice(`Archive failed: ${error.message}`);
    }
  }
};
