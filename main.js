/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => PARAArchivePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian6 = require("obsidian");

// settings.ts
var DEFAULT_SETTINGS = {
  archiveConfigs: [
    {
      id: "default",
      name: "Default",
      rootPath: "",
      archivePath: "Archive",
      archiveMode: "path-mirror"
    }
  ],
  showConfirmation: true,
  linkUpdateMode: "always",
  showUndoNotice: true,
  undoTimeoutMs: 5e3
};

// settings-tab.ts
var import_obsidian2 = require("obsidian");

// folder-suggest.ts
var import_obsidian = require("obsidian");
var FolderSuggest = class extends import_obsidian.AbstractInputSuggest {
  constructor(app, inputEl, onSelectCallback) {
    super(app, inputEl);
    this.onSelectCallback = onSelectCallback;
  }
  getSuggestions(query) {
    const allFolders = this.app.vault.getAllFolders();
    const lowerCaseInputStr = query.toLowerCase();
    return allFolders.filter((folder) => {
      return folder.path.toLowerCase().contains(lowerCaseInputStr);
    });
  }
  renderSuggestion(folder, el) {
    el.createEl("div", { text: folder.path });
  }
  selectSuggestion(folder) {
    this.setValue(folder.path);
    if (this.onSelectCallback) {
      this.onSelectCallback(folder.path);
    }
    this.close();
  }
};

// settings-tab.ts
var PARAArchiveSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian2.Setting(containerEl).setName("PARA archive settings").setHeading();
    new import_obsidian2.Setting(containerEl).setName("Show confirmation dialog").setDesc("Show a confirmation dialog before archiving files").addToggle((toggle) => toggle.setValue(this.plugin.settings.showConfirmation).onChange(async (value) => {
      this.plugin.settings.showConfirmation = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Link update mode").setDesc("How to handle internal links when archiving files").addDropdown((dropdown) => dropdown.addOption("always", "Always update links").addOption("ask", "Ask before updating").addOption("never", "Never update links").setValue(this.plugin.settings.linkUpdateMode).onChange(async (value) => {
      this.plugin.settings.linkUpdateMode = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Show undo notification").setDesc("Show a temporary notification with an undo button after archiving files").addToggle((toggle) => toggle.setValue(this.plugin.settings.showUndoNotice).onChange(async (value) => {
      this.plugin.settings.showUndoNotice = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Undo timeout (seconds)").setDesc("How long the undo notification stays visible").addSlider((slider) => slider.setLimits(1, 15, 1).setValue(this.plugin.settings.undoTimeoutMs / 1e3).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.undoTimeoutMs = value * 1e3;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Archive configurations").setHeading();
    containerEl.createEl("p", { text: "Configure different archive setups for different parts of your vault (e.g., Personal, Work)" });
    new import_obsidian2.Setting(containerEl).setName("Add new archive configuration").addButton((button) => button.setButtonText("Add").setCta().onClick(() => {
      this.addNewArchiveConfig();
    }));
    this.plugin.settings.archiveConfigs.forEach((config, index) => {
      this.displayArchiveConfig(containerEl, config, index);
    });
  }
  addNewArchiveConfig() {
    const newConfig = {
      id: Date.now().toString(),
      name: "New Configuration",
      rootPath: "",
      archivePath: "Archive",
      archiveMode: "date-based"
    };
    this.plugin.settings.archiveConfigs.push(newConfig);
    this.plugin.saveSettings();
    this.display();
  }
  displayArchiveConfig(containerEl, config, index) {
    const configDiv = containerEl.createDiv("archive-config");
    configDiv.createEl("h4", { text: `Configuration: ${config.name}` });
    new import_obsidian2.Setting(configDiv).setName("Configuration name").setDesc("A friendly name for this archive configuration").addText((text) => text.setValue(config.name).onChange(async (value) => {
      config.name = value;
      await this.plugin.saveSettings();
      configDiv.querySelector("h4").textContent = `Configuration: ${config.name}`;
    }));
    new import_obsidian2.Setting(configDiv).setName("Root path").setDesc('The root folder path this configuration applies to (e.g., "Personal", "Work"). Leave empty for vault root.').addSearch((search) => {
      search.setPlaceholder("Select or type folder path...").setValue(config.rootPath).onChange(async (value) => {
        config.rootPath = value;
        await this.plugin.saveSettings();
      });
      new FolderSuggest(this.app, search.inputEl, async (value) => {
        config.rootPath = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(configDiv).setName("Archive path").setDesc("The folder where archived files will be moved (relative to root path)").addSearch((search) => {
      search.setPlaceholder("Select or type archive folder path...").setValue(config.archivePath).onChange(async (value) => {
        config.archivePath = value;
        await this.plugin.saveSettings();
      });
      new FolderSuggest(this.app, search.inputEl, async (value) => {
        config.archivePath = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(configDiv).setName("Archive mode").setDesc("How files should be organized in the archive folder").addDropdown((dropdown) => dropdown.addOption("date-based", "Date-based (YYYY-MM folders)").addOption("path-mirror", "Mirror original path structure").setValue(config.archiveMode).onChange(async (value) => {
      config.archiveMode = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(configDiv).setName("Remove configuration").addButton((button) => button.setButtonText("Remove").setWarning().onClick(async () => {
      this.plugin.settings.archiveConfigs.splice(index, 1);
      await this.plugin.saveSettings();
      this.display();
    }));
    configDiv.createEl("hr");
  }
};

// archiver.ts
var import_obsidian3 = require("obsidian");
var Archiver = class {
  constructor(app) {
    this.app = app;
    this.vault = app.vault;
  }
  /**
   * Determines which archive configuration applies to a given file path
   */
  findArchiveConfig(filePath, configs) {
    const sortedConfigs = configs.sort((a, b) => b.rootPath.length - a.rootPath.length);
    for (const config of sortedConfigs) {
      if (this.isFileInRoot(filePath, config.rootPath)) {
        return config;
      }
    }
    return null;
  }
  /**
   * Checks if a file is already in an archive folder
   */
  isFileInArchive(filePath, configs) {
    for (const config of configs) {
      const archiveFullPath = this.getArchiveFullPath(config);
      if (filePath.startsWith(archiveFullPath + "/") || filePath === archiveFullPath) {
        return true;
      }
    }
    return false;
  }
  /**
   * Generates the destination path for archiving a file
   */
  generateArchivePath(filePath, config) {
    const archiveBasePath = this.getArchiveFullPath(config);
    if (config.archiveMode === "date-based") {
      return this.generateDateBasedPath(filePath, archiveBasePath);
    } else {
      return this.generatePathMirrorPath(filePath, config, archiveBasePath);
    }
  }
  /**
   * Archives a file or folder to the appropriate location
   */
  async archiveFile(file, config) {
    const destinationPath = this.generateArchivePath(file.path, config);
    const existingItem = this.vault.getAbstractFileByPath(destinationPath);
    if (file instanceof import_obsidian3.TFolder && existingItem instanceof import_obsidian3.TFolder) {
      await this.mergeFolderContents(file, existingItem);
      await this.app.fileManager.trashFile(file);
    } else {
      await this.ensureDirectoryExists(destinationPath);
      await this.vault.rename(file, destinationPath);
    }
    return destinationPath;
  }
  /**
   * Undoes an archive operation by moving the file/folder back to its original location
   */
  async undoArchive(operation) {
    const archivedFile = this.vault.getAbstractFileByPath(operation.destinationPath);
    if (!archivedFile) {
      throw new Error("Archived file no longer exists and cannot be restored");
    }
    const existingFile = this.vault.getAbstractFileByPath(operation.originalPath);
    if (existingFile) {
      const uniquePath = this.generateUniquePath(operation.originalPath);
      await this.vault.rename(archivedFile, uniquePath);
      throw new Error(`Original location is occupied. File restored to: ${uniquePath}`);
    }
    await this.ensureDirectoryExists(operation.originalPath);
    await this.vault.rename(archivedFile, operation.originalPath);
  }
  /**
   * Merges contents of source folder into destination folder
   */
  async mergeFolderContents(sourceFolder, destinationFolder) {
    for (const child of sourceFolder.children) {
      const childDestinationPath = (0, import_obsidian3.normalizePath)(`${destinationFolder.path}/${child.name}`);
      try {
        const existingChild = this.vault.getAbstractFileByPath(childDestinationPath);
        if (child instanceof import_obsidian3.TFolder && existingChild instanceof import_obsidian3.TFolder) {
          await this.mergeFolderContents(child, existingChild);
          await this.app.fileManager.trashFile(child);
        } else if (existingChild) {
          const uniquePath = this.generateUniquePath(childDestinationPath);
          await this.vault.rename(child, uniquePath);
        } else {
          await this.vault.rename(child, childDestinationPath);
        }
      } catch (error) {
        console.error(`Failed to move ${child.path} to ${childDestinationPath}:`, error);
        throw error;
      }
    }
  }
  /**
   * Generates a unique path by adding numbers if needed
   */
  generateUniquePath(basePath) {
    let counter = 1;
    let newPath = basePath;
    while (this.vault.getAbstractFileByPath(newPath)) {
      const pathParts = basePath.split(".");
      if (pathParts.length > 1) {
        const extension = pathParts.pop();
        const nameWithoutExt = pathParts.join(".");
        newPath = `${nameWithoutExt} ${counter}.${extension}`;
      } else {
        newPath = `${basePath} ${counter}`;
      }
      counter++;
    }
    return newPath;
  }
  isFileInRoot(filePath, rootPath) {
    if (!rootPath) {
      return true;
    }
    const normalizedRoot = (0, import_obsidian3.normalizePath)(rootPath);
    const normalizedFile = (0, import_obsidian3.normalizePath)(filePath);
    return normalizedFile.startsWith(normalizedRoot + "/") || normalizedFile === normalizedRoot;
  }
  getArchiveFullPath(config) {
    if (!config.rootPath || config.archivePath.startsWith(config.rootPath)) {
      return (0, import_obsidian3.normalizePath)(config.archivePath);
    }
    return (0, import_obsidian3.normalizePath)(`${config.rootPath}/${config.archivePath}`);
  }
  generateDateBasedPath(filePath, archiveBasePath) {
    const now = new Date();
    const yearMonth = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, "0")}`;
    const fileName = filePath.split("/").pop() || "";
    return (0, import_obsidian3.normalizePath)(`${archiveBasePath}/${yearMonth}/${fileName}`);
  }
  generatePathMirrorPath(filePath, config, archiveBasePath) {
    let relativePath = filePath;
    if (config.rootPath) {
      const normalizedRoot = (0, import_obsidian3.normalizePath)(config.rootPath);
      if (filePath.startsWith(normalizedRoot + "/")) {
        relativePath = filePath.substring(normalizedRoot.length + 1);
      } else if (filePath === normalizedRoot) {
        relativePath = normalizedRoot.split("/").pop() || "";
      }
    }
    return (0, import_obsidian3.normalizePath)(`${archiveBasePath}/${relativePath}`);
  }
  async ensureDirectoryExists(filePath) {
    const directory = filePath.substring(0, filePath.lastIndexOf("/"));
    if (directory && !this.vault.getAbstractFileByPath(directory)) {
      const pathParts = directory.split("/");
      let currentPath = "";
      for (const part of pathParts) {
        currentPath = currentPath ? `${currentPath}/${part}` : part;
        const normalizedPath = (0, import_obsidian3.normalizePath)(currentPath);
        if (!this.vault.getAbstractFileByPath(normalizedPath)) {
          await this.vault.createFolder(normalizedPath);
        }
      }
    }
  }
};

// link-updater.ts
var LinkUpdater = class {
  constructor(app) {
    this.app = app;
    this.vault = app.vault;
    this.metadataCache = app.metadataCache;
  }
  /**
   * Finds all files that link to the given file
   */
  async findLinksToFile(targetFile) {
    const linkedFiles = [];
    const allFiles = this.vault.getMarkdownFiles();
    for (const file of allFiles) {
      const cache = this.metadataCache.getFileCache(file);
      if (!cache)
        continue;
      if (cache.links) {
        for (const link of cache.links) {
          const linkedFile = this.metadataCache.getFirstLinkpathDest(link.link, file.path);
          if (linkedFile && linkedFile.path === targetFile.path) {
            linkedFiles.push(file);
            break;
          }
        }
      }
      if (cache.embeds) {
        for (const embed of cache.embeds) {
          const linkedFile = this.metadataCache.getFirstLinkpathDest(embed.link, file.path);
          if (linkedFile && linkedFile.path === targetFile.path) {
            if (linkedFiles.indexOf(file) === -1) {
              linkedFiles.push(file);
            }
            break;
          }
        }
      }
    }
    return linkedFiles;
  }
  /**
   * Prepares link updates for all files that reference files within a moved folder
   */
  async prepareFolderLinkUpdates(oldFolderPath, newFolderPath) {
    const updates = [];
    const allFiles = this.vault.getMarkdownFiles();
    const filesInFolder = this.vault.getMarkdownFiles().filter(
      (file) => file.path.startsWith(oldFolderPath + "/") || file.path === oldFolderPath
    );
    for (const fileInFolder of filesInFolder) {
      const relativePath = fileInFolder.path.substring(oldFolderPath.length);
      const newFilePath = newFolderPath + relativePath;
      const fileUpdates = await this.prepareLinkUpdates(fileInFolder.path, newFilePath);
      updates.push(...fileUpdates);
    }
    return updates;
  }
  /**
   * Prepares link updates for all files that reference the moved file
   */
  async prepareLinkUpdates(oldPath, newPath) {
    const updates = [];
    const allFiles = this.vault.getMarkdownFiles();
    for (const file of allFiles) {
      const content = await this.vault.read(file);
      const newContent = this.updateLinksInContent(content, oldPath, newPath, file.path);
      if (content !== newContent) {
        const linkCount = this.countUpdatedLinks(content, newContent);
        updates.push({
          file,
          oldContent: content,
          newContent,
          linkCount
        });
      }
    }
    return updates;
  }
  /**
   * Applies all prepared link updates
   */
  async applyLinkUpdates(updates) {
    let success = 0;
    const failed = [];
    for (const update of updates) {
      try {
        await this.vault.modify(update.file, update.newContent);
        success++;
      } catch (error) {
        failed.push(update.file.path);
        console.error(`Failed to update links in ${update.file.path}:`, error);
      }
    }
    return { success, failed };
  }
  /**
   * Updates all links in content that point to the old path
   */
  updateLinksInContent(content, oldPath, newPath, currentFilePath) {
    var _a;
    let updatedContent = content;
    const oldFileName = ((_a = oldPath.split("/").pop()) == null ? void 0 : _a.replace(/\.[^/.]+$/, "")) || "";
    const newRelativePath = this.getRelativePath(currentFilePath, newPath);
    updatedContent = this.updateWikilinks(updatedContent, oldPath, newPath, oldFileName, newRelativePath, currentFilePath);
    updatedContent = this.updateMarkdownLinks(updatedContent, oldPath, newPath, currentFilePath);
    return updatedContent;
  }
  updateWikilinks(content, oldPath, newPath, oldFileName, newRelativePath, currentFilePath) {
    const wikilinkRegex = /\[\[([^\]|#^]+)([#^][^\]|]*)?\|?([^\]]*)?\]\]/g;
    return content.replace(wikilinkRegex, (match, linkPath, anchor, alias) => {
      var _a;
      const resolvedFile = this.metadataCache.getFirstLinkpathDest(linkPath.trim(), currentFilePath);
      if (resolvedFile && resolvedFile.path === oldPath) {
        const anchorPart = anchor || "";
        const newFileName = ((_a = newPath.split("/").pop()) == null ? void 0 : _a.replace(/\.[^/.]+$/, "")) || "";
        let newLinkPath;
        if (this.isFilenameUnique(newFileName)) {
          newLinkPath = newFileName;
        } else {
          newLinkPath = newRelativePath.replace(/\.[^/.]+$/, "");
        }
        let aliasPart = "";
        if (alias) {
          aliasPart = `|${alias}`;
        } else if (newLinkPath !== newFileName && newLinkPath.includes("/")) {
          aliasPart = `|${newFileName}`;
        }
        return `[[${newLinkPath}${anchorPart}${aliasPart}]]`;
      }
      return match;
    });
  }
  updateMarkdownLinks(content, oldPath, newPath, currentFilePath) {
    const markdownLinkRegex = /(!?)\[([^\]]*)\]\(([^)]+)\)/g;
    return content.replace(markdownLinkRegex, (match, isEmbed, text, linkPath) => {
      const resolvedFile = this.metadataCache.getFirstLinkpathDest(linkPath.trim(), currentFilePath);
      if (resolvedFile && resolvedFile.path === oldPath) {
        const newRelativePath = this.getRelativePath(currentFilePath, newPath);
        return `${isEmbed}[${text}](${newRelativePath})`;
      }
      return match;
    });
  }
  getRelativePath(fromPath, toPath) {
    const fromParts = fromPath.split("/");
    const toParts = toPath.split("/");
    fromParts.pop();
    let commonLength = 0;
    for (let i = 0; i < Math.min(fromParts.length, toParts.length); i++) {
      if (fromParts[i] === toParts[i]) {
        commonLength++;
      } else {
        break;
      }
    }
    const upDirs = fromParts.length - commonLength;
    const relativeParts = [];
    for (let i = 0; i < upDirs; i++) {
      relativeParts.push("..");
    }
    relativeParts.push(...toParts.slice(commonLength));
    return relativeParts.join("/");
  }
  countUpdatedLinks(oldContent, newContent) {
    if (oldContent === newContent) {
      return 0;
    }
    const oldLines = oldContent.split("\n");
    const newLines = newContent.split("\n");
    let linkChanges = 0;
    for (let i = 0; i < Math.max(oldLines.length, newLines.length); i++) {
      const oldLine = oldLines[i] || "";
      const newLine = newLines[i] || "";
      if (oldLine !== newLine) {
        const linksInLine = (newLine.match(/\[\[.*?\]\]|\[.*?\]\(.*?\)/g) || []).length;
        linkChanges += linksInLine;
      }
    }
    return linkChanges;
  }
  /**
   * Check if a filename is unique in the vault (no naming conflicts)
   */
  isFilenameUnique(filename) {
    const allFiles = this.vault.getMarkdownFiles();
    const matchingFiles = allFiles.filter((file) => {
      const fileBasename = file.basename;
      return fileBasename === filename;
    });
    return matchingFiles.length <= 1;
  }
};

// confirmation-modal.ts
var import_obsidian4 = require("obsidian");
var ArchiveConfirmationModal = class extends import_obsidian4.Modal {
  constructor(app, file, config, destinationPath, linkUpdates, onConfirm, onCancel) {
    super(app);
    this.file = file;
    this.config = config;
    this.destinationPath = destinationPath;
    this.linkUpdates = linkUpdates;
    this.onConfirm = onConfirm;
    this.onCancel = onCancel;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Confirm Archive Operation" });
    const fileInfoDiv = contentEl.createDiv("archive-file-info");
    fileInfoDiv.createEl("h3", { text: "File to Archive" });
    const fileTypeIcon = this.file instanceof import_obsidian4.TFile ? "\u{1F4C4}" : "\u{1F4C1}";
    fileInfoDiv.createEl("p", {
      text: `${fileTypeIcon} ${this.file.name}`,
      cls: "archive-file-name"
    });
    fileInfoDiv.createEl("p", {
      text: `Current path: ${this.file.path}`,
      cls: "archive-current-path"
    });
    const archiveInfoDiv = contentEl.createDiv("archive-destination-info");
    archiveInfoDiv.createEl("h3", { text: "Archive Details" });
    archiveInfoDiv.createEl("p", { text: `Configuration: ${this.config.name}` });
    archiveInfoDiv.createEl("p", { text: `Archive mode: ${this.config.archiveMode}` });
    archiveInfoDiv.createEl("p", {
      text: `Destination: ${this.destinationPath}`,
      cls: "archive-destination-path"
    });
    if (this.linkUpdates.length > 0) {
      const linkInfoDiv = contentEl.createDiv("archive-link-info");
      linkInfoDiv.createEl("h3", { text: "Link Updates" });
      const totalLinks = this.linkUpdates.reduce((sum, update) => sum + update.linkCount, 0);
      linkInfoDiv.createEl("p", {
        text: `${this.linkUpdates.length} files with ${totalLinks} links will be updated`
      });
      const fileList = linkInfoDiv.createEl("ul", { cls: "archive-link-files" });
      const filesToShow = this.linkUpdates.slice(0, 5);
      filesToShow.forEach((update) => {
        const listItem = fileList.createEl("li");
        listItem.createEl("span", { text: update.file.name, cls: "file-name" });
        listItem.createEl("span", {
          text: ` (${update.linkCount} links)`,
          cls: "link-count"
        });
      });
      if (this.linkUpdates.length > 5) {
        fileList.createEl("li", {
          text: `... and ${this.linkUpdates.length - 5} more files`,
          cls: "more-files"
        });
      }
    } else {
      const noLinksDiv = contentEl.createDiv("archive-no-links");
      noLinksDiv.createEl("p", {
        text: "No links to this file were found.",
        cls: "no-links-message"
      });
    }
    const existingFile = this.app.vault.getAbstractFileByPath(this.destinationPath);
    if (existingFile) {
      const warningDiv = contentEl.createDiv("archive-warning");
      warningDiv.createEl("p", {
        text: "\u26A0\uFE0F A file or folder already exists at the destination path. It will be overwritten.",
        cls: "warning-message"
      });
    }
    const buttonDiv = contentEl.createDiv("archive-buttons");
    buttonDiv.createEl("button", { text: "Cancel" }).addEventListener("click", () => {
      this.onCancel();
      this.close();
    });
    const confirmButton = buttonDiv.createEl("button", {
      text: "Archive",
      cls: "mod-cta"
    });
    confirmButton.addEventListener("click", async () => {
      confirmButton.disabled = true;
      confirmButton.textContent = "Archiving...";
      try {
        await this.onConfirm();
        this.close();
      } catch (error) {
        confirmButton.disabled = false;
        confirmButton.textContent = "Archive";
        console.error("Archive operation failed:", error);
      }
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// undo-notice.ts
var import_obsidian5 = require("obsidian");
var UndoNotice = class extends import_obsidian5.Notice {
  constructor(message, undoCallback, timeoutMs = 5e3) {
    super("", timeoutMs);
    this.undoCallback = undoCallback;
    this.messageEl.empty();
    this.createNoticeContent(message);
    this.timeoutId = window.setTimeout(() => {
      this.hide();
    }, timeoutMs);
  }
  createNoticeContent(message) {
    const container = this.messageEl.createDiv("undo-notice-container");
    const messageEl = container.createSpan("undo-notice-message");
    messageEl.textContent = message;
    this.undoButton = container.createEl("button", {
      text: "Undo",
      cls: "undo-notice-button"
    });
    this.undoButton.addEventListener("click", this.handleUndo.bind(this));
  }
  handleUndo() {
    if (this.timeoutId) {
      window.clearTimeout(this.timeoutId);
    }
    this.undoCallback();
    this.showUndoInProgress();
    setTimeout(() => {
      this.hide();
    }, 1500);
  }
  showUndoInProgress() {
    this.messageEl.empty();
    const container = this.messageEl.createDiv("undo-notice-container");
    const messageEl = container.createSpan("undo-notice-message");
    messageEl.textContent = "Undoing archive operation...";
    const spinner = container.createSpan("undo-notice-spinner");
    spinner.textContent = "\u23F3";
  }
  hide() {
    if (this.timeoutId) {
      window.clearTimeout(this.timeoutId);
    }
    super.hide();
  }
};

// main.ts
var PARAArchivePlugin = class extends import_obsidian6.Plugin {
  constructor() {
    super(...arguments);
    this.pendingOperations = /* @__PURE__ */ new Map();
  }
  async onload() {
    await this.loadSettings();
    this.archiver = new Archiver(this.app);
    this.linkUpdater = new LinkUpdater(this.app);
    this.addSettingTab(new PARAArchiveSettingTab(this.app, this));
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        this.addArchiveMenuItem(menu, file);
      })
    );
    this.addCommand({
      id: "archive-current-file",
      name: "Archive current file",
      checkCallback: (checking) => {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile) {
          if (!checking) {
            this.archiveFile(activeFile);
          }
          return true;
        }
        return false;
      }
    });
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  addArchiveMenuItem(menu, file) {
    if (this.archiver.isFileInArchive(file.path, this.settings.archiveConfigs)) {
      return;
    }
    const config = this.archiver.findArchiveConfig(file.path, this.settings.archiveConfigs);
    if (!config) {
      return;
    }
    menu.addItem((item) => {
      item.setTitle("PARA Archive").setIcon("archive").onClick(() => {
        this.archiveFile(file);
      });
    });
  }
  async archiveFile(file) {
    try {
      const config = this.archiver.findArchiveConfig(file.path, this.settings.archiveConfigs);
      if (!config) {
        new import_obsidian6.Notice("No archive configuration found for this file location");
        return;
      }
      if (this.archiver.isFileInArchive(file.path, this.settings.archiveConfigs)) {
        new import_obsidian6.Notice("File is already in an archive folder");
        return;
      }
      const destinationPath = this.archiver.generateArchivePath(file.path, config);
      let linkUpdates = [];
      if (this.settings.linkUpdateMode !== "never") {
        if (file instanceof import_obsidian6.TFile) {
          linkUpdates = await this.linkUpdater.prepareLinkUpdates(file.path, destinationPath);
        } else if (file instanceof import_obsidian6.TFolder) {
          linkUpdates = await this.linkUpdater.prepareFolderLinkUpdates(file.path, destinationPath);
        }
      }
      if (this.settings.showConfirmation) {
        new ArchiveConfirmationModal(
          this.app,
          file,
          config,
          destinationPath,
          linkUpdates,
          async () => {
            await this.performArchive(file, config, destinationPath, linkUpdates);
          },
          () => {
          }
        ).open();
      } else {
        await this.performArchive(file, config, destinationPath, linkUpdates);
      }
    } catch (error) {
      console.error("Archive operation failed:", error);
      new import_obsidian6.Notice(`Archive failed: ${error.message}`);
    }
  }
  async performArchive(file, config, destinationPath, linkUpdates) {
    try {
      const originalPath = file.path;
      await this.archiver.archiveFile(file, config);
      let appliedLinkUpdates = [];
      let successMessage = "File archived successfully";
      if (this.settings.linkUpdateMode === "always" && linkUpdates.length > 0) {
        const result = await this.linkUpdater.applyLinkUpdates(linkUpdates);
        appliedLinkUpdates = linkUpdates;
        if (result.failed.length > 0) {
          successMessage = `File archived. Updated ${result.success} files, failed to update ${result.failed.length} files.`;
        } else {
          successMessage = `File archived successfully. Updated ${result.success} files with links.`;
        }
      } else if (this.settings.linkUpdateMode === "ask" && linkUpdates.length > 0) {
        successMessage = `File archived. ${linkUpdates.length} files contain links to this file.`;
      }
      if (this.settings.showUndoNotice) {
        this.showUndoNotice(originalPath, destinationPath, appliedLinkUpdates, config, successMessage);
      } else {
        new import_obsidian6.Notice(successMessage);
      }
    } catch (error) {
      console.error("Archive operation failed:", error);
      new import_obsidian6.Notice(`Archive failed: ${error.message}`);
    }
  }
  showUndoNotice(originalPath, destinationPath, linkUpdates, config, message) {
    const operation = {
      originalPath,
      destinationPath,
      linkUpdates,
      timestamp: Date.now(),
      config
    };
    const operationId = `${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;
    this.pendingOperations.set(operationId, operation);
    const undoNotice = new UndoNotice(
      message,
      async () => {
        await this.performUndo(operationId);
      },
      this.settings.undoTimeoutMs
    );
    setTimeout(() => {
      this.pendingOperations.delete(operationId);
    }, this.settings.undoTimeoutMs + 1e3);
  }
  async performUndo(operationId) {
    const operation = this.pendingOperations.get(operationId);
    if (!operation) {
      new import_obsidian6.Notice("Undo operation has expired");
      return;
    }
    try {
      await this.archiver.undoArchive(operation);
      if (operation.linkUpdates.length > 0) {
        const reverseLinkUpdates = operation.linkUpdates.map((update) => ({
          ...update,
          oldContent: update.newContent,
          newContent: update.oldContent
        }));
        await this.linkUpdater.applyLinkUpdates(reverseLinkUpdates);
      }
      this.pendingOperations.delete(operationId);
      new import_obsidian6.Notice("Archive operation undone successfully");
    } catch (error) {
      console.error("Undo failed:", error);
      new import_obsidian6.Notice(`Undo failed: ${error.message}`);
    }
  }
};
